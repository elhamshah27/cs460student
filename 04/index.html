<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Flashy Fish!</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;

        /* Background image (absolute, then relative, then course fallback) */
        background-image:
          url('file:///C:/Users/elham/OneDrive/Documents/cs460student/04/background.jpg'),
          url('file:///C:/Users/elham/OneDrive/Documents/cs460student/04/background.jpeg'),
          url('background.jpg'),
          url('background.jpeg'),
          url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }
      #c { width: 100%; height: 100%; }

      /* HUD */
      #timeHud, #scoreHud {
        position: fixed;
        top: 12px;
        font-family: system-ui, Arial, sans-serif;
        font-size: 18px;
        color: white;
        text-shadow: 0 1px 3px rgba(0,0,0,.85);
        user-select: none;
        pointer-events: none;
      }
      #timeHud { left: 16px; }
      #scoreHud { right: 16px; }

      /* End banner */
      #banner {
        position: fixed; inset: 0; display: none;
        align-items: center; justify-content: center;
        font-family: system-ui, Arial, sans-serif;
        font-size: 48px; color: white; text-shadow: 0 2px 8px rgba(0,0,0,.9);
        background: rgba(0,0,0,.35);
        user-select: none; text-align: center;
      }
      #banner small { display: block; font-size: 18px; margin-top: 8px; opacity: .9; }

      /* Title screen overlay */
      #title {
        position: fixed; inset: 0;
        display: flex; align-items: center; justify-content: center;
        background: rgba(0,0,0,.45);
        color: white; text-shadow: 0 2px 8px rgba(0,0,0,.9);
        font-family: system-ui, Arial, sans-serif;
        user-select: none; text-align: center; padding: 24px;
      }
      #title .card {
        background: rgba(0,0,0,.35);
        border-radius: 16px;
        padding: 24px 28px;
        box-shadow: 0 10px 30px rgba(0,0,0,.35);
        max-width: 680px;
      }
      #title h1 {
        margin: 0 0 8px 0; font-size: 42px;
      }
      #title p {
        margin: 8px 0; font-size: 18px; line-height: 1.4;
      }
      #title .controls {
        margin-top: 12px; font-size: 16px; opacity: .95;
      }
      #title .start {
        display: inline-block; margin-top: 16px; padding: 10px 16px;
        background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.35);
        border-radius: 10px; font-size: 18px; cursor: pointer;
        user-select: none; pointer-events: auto;
      }
      #title .start:hover { background: rgba(255,255,255,.2); }
      #title small { display: block; margin-top: 10px; opacity: .9; }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>

    <!-- HUD -->
    <div id="timeHud">Time: <span id="time">60.0</span>s</div>
    <div id="scoreHud">Fish eaten: <span id="score">0</span>/<span id="target">30</span></div>

    <!-- Title Screen -->
    <div id="title">
      <div class="card">
        <h1>Flashy Fish!</h1>
        <p>Swim around and <b>eat the small fish</b> to score points.</p>
        <p><b>Avoid the bombs</b> — hitting one ends the game.</p>
        <div class="controls">
          <p><b>Move:</b> WASD or Arrow Keys</p>
          <p><b>Speed Boost:</b> Hold Shift</p>
          <p><b>Goal:</b> Eat <span id="title-target">30</span> fish before time runs out</p>
        </div>
        <div class="start" id="startBtn">Click to Start</div>
        <small>(or press Space / Enter)</small>
      </div>
    </div>

    <!-- End banner -->
    <div id="banner"><span id="banner-text">Game Over</span><small>Press R to restart</small></div>

    <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>

    <!--************************************************************-->
    <!-- VERTEX SHADER -->
    <script id="vertexshader" type="glsl">
      attribute vec3 a_position;
      uniform mat4  u_transform;
      uniform float u_pointsize;
      void main(void) {
        gl_Position = u_transform * vec4(a_position, 1.0);
        gl_PointSize = u_pointsize;
      }
    </script>

    <!--************************************************************-->
    <!-- FRAGMENT SHADER -->
    <script id="fragmentshader" type="glsl">
      precision mediump float;
      uniform vec4  u_color;
      uniform float u_mode;
      uniform float u_time;

      void main(void) {
        if (u_mode < 0.5) {
          gl_FragColor = u_color; // fish & eyes (solid)
          return;
        }
        // Bomb sprite
        vec2 p = gl_PointCoord * 2.0 - 1.0;
        float r = length(p);
        if (r > 1.0) discard;
        float glow = 0.50 + 0.50 * (0.5 + 0.5 * sin(u_time * 6.0));
        float rim  = smoothstep(0.80, 1.00, r);
        vec3 base  = vec3(0.10, 0.10, 0.10);
        vec3 col   = base + glow * vec3(0.35, 0.15, 0.35) * (1.0 - r);
        col        = mix(col, vec3(1.0, 0.6, 1.0), rim*0.25);
        gl_FragColor = vec4(col, 0.95);
      }
    </script>

    <script>
      var c, gl;
      var v_shader, f_shader, shaderprogram;

      // Fish tuple:
      // [0]=v_buffer, [1]=i_buffer, [2]=eye_v_buffer, [3]=color, [4]=offset(vec3), [5]=scale, [6]=direction(±1)
      var all_fish = [];

      // ----------- Game config -------------
      const NUM_FISH      = 35;
      const BOMB_COUNT    = 6;
      const TARGET_SCORE  = 30;     // updated target
      const TIME_TOTAL    = 60.0;
      const TIME_BONUS    = 2.0;

      var keysDown = {};
      var baseSpeed = 0.012;
      var boostMult = 2.0;
      var clampMinX = -0.92, clampMaxX = 0.92;
      var clampMinY = -0.92, clampMaxY = 0.92;

      // Bombs from sides: {x,y,size,speed,phase,dir}
      var bombs = [];

      // HUD / state
      var score = 0;
      var startTimeMs = 0;
      var frozenTimeLeft = null;

      var timeEl, scoreEl, targetEl, bannerEl, bannerTextEl, titleEl, titleTargetEl, startBtn;

      // Game state: 'title' | 'playing' | 'ended'
      var gameState = 'title';

      // Shared GL point buffer (eyes & bombs)
      var pointBuffer = null;

      // Audio
      var audioCtx = null;
      function ensureAudio(){
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      function beep(freq=880, dur=0.12, type='sine', vol=0.25){
        if (!audioCtx) return;
        const t0 = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t0);
        gain.gain.setValueAtTime(0, t0);
        gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
        gain.gain.linearRampToValueAtTime(0, t0 + dur);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(t0); osc.stop(t0 + dur + 0.02);
      }
      function eatSound(){ ensureAudio(); beep(1100, 0.07, 'sine', 0.35); setTimeout(()=>beep(1600, 0.06, 'sine', 0.28), 50); }
      function bombSound(){ ensureAudio(); beep(240, 0.22, 'square', 0.4); }

      window.addEventListener('keydown', ()=>ensureAudio(), {once:true});
      window.addEventListener('pointerdown', ()=>ensureAudio(), {once:true});

      // Input
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        keysDown[k] = true;

        if ((k === ' ' || k === 'enter') && gameState === 'title') startGame();

        // R restarts immediately into gameplay (from ended OR while playing)
        if (k === 'r' && (gameState === 'ended' || gameState === 'playing')) restartGame();
      });
      window.addEventListener('keyup', (e) => { keysDown[e.key.toLowerCase()] = false; });

      window.onload = function() {
        // HUD refs
        timeEl = document.getElementById('time');
        scoreEl = document.getElementById('score');
        targetEl = document.getElementById('target');
        bannerEl = document.getElementById('banner');
        bannerTextEl = document.getElementById('banner-text');
        titleEl = document.getElementById('title');
        titleTargetEl = document.getElementById('title-target');
        startBtn = document.getElementById('startBtn');

        targetEl.textContent = TARGET_SCORE;
        titleTargetEl.textContent = TARGET_SCORE;

        startBtn.addEventListener('click', startGame);

        // Canvas & GL
        c = document.getElementById('c');
        c.width  = window.innerWidth;
        c.height = window.innerHeight;

        gl = c.getContext('webgl');
        gl.viewport(0, 0, c.width, c.height);

        // Shaders
        v_shader = gl.createShader(gl.VERTEX_SHADER);
        f_shader = gl.createShader(gl.FRAGMENT_SHADER);

        gl.shaderSource(v_shader, document.getElementById('vertexshader').innerText);
        gl.compileShader(v_shader);
        if (!gl.getShaderParameter(v_shader, gl.COMPILE_STATUS)) console.log(gl.getShaderInfoLog(v_shader));

        gl.shaderSource(f_shader, document.getElementById('fragmentshader').innerText);
        gl.compileShader(f_shader);
        if (!gl.getShaderParameter(f_shader, gl.COMPILE_STATUS)) console.log(gl.getShaderInfoLog(f_shader));

        shaderprogram = gl.createProgram();
        gl.attachShader(shaderprogram, v_shader);
        gl.attachShader(shaderprogram, f_shader);
        gl.linkProgram(shaderprogram);
        gl.useProgram(shaderprogram);

        pointBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0,0]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // Big red fish (index 0)
        all_fish.push(createFish(
          new Float32Array([0.0, 0.0, 0.0]),
          new Float32Array([1.0, 0.0, 0.0, 0.7]),
          1.0,
          -1
        ));

        // Small fish (uniform scatter)
        for (let i = 0; i < NUM_FISH; i++) {
          const random_color  = new Float32Array([Math.random(), Math.random(), Math.random(), 0.9]);
          const random_offset = new Float32Array([
            (Math.random()*1.8) - 0.9,
            (Math.random()*1.8) - 0.9,
            0
          ]);
          const random_scale  = 0.08 + Math.random() * 0.10;
          const dir = Math.random() < 0.5 ? -1 : 1;
          all_fish.push(createFish(random_offset, random_color, random_scale, dir));
        }

        initBombs();

        // Start at title
        score = 0; frozenTimeLeft = null; gameState = 'title';
        scoreEl.textContent = score;
        bannerEl.style.display = 'none';
        titleEl.style.display = 'flex';
        timeEl.textContent = TIME_TOTAL.toFixed(1);
        animate();
      };

      function startGame(){
        if (gameState !== 'title') return;
        score = 0; scoreEl.textContent = score;
        frozenTimeLeft = null;
        bannerEl.style.display = 'none';
        titleEl.style.display = 'none';
        startTimeMs = performance.now();
        gameState = 'playing';
      }

      // direct restart into gameplay
      function restartGame(){
        // reseed small fish randomly across the screen
        for (let i = 1; i < all_fish.length; i++) {
          var fish = all_fish[i];
          fish[4] = new Float32Array([
            (Math.random()*1.8) - 0.9,
            (Math.random()*1.8) - 0.9,
            0
          ]);
          fish[6] = (Math.random() < 0.5) ? -1 : 1;
          setEyeForDirection(fish[2], fish[6]);
          fish[3] = new Float32Array([Math.random(), Math.random(), Math.random(), 0.9]);
          fish[5] = 0.08 + Math.random() * 0.10;
        }
        initBombs();
        score = 0; scoreEl.textContent = score;
        frozenTimeLeft = null;
        bannerEl.style.display = 'none';
        titleEl.style.display = 'none';  // ensure we don't go back to title
        startTimeMs = performance.now();
        gameState = 'playing';
      }

      function initBombs(){
        bombs = [];
        for (let i = 0; i < BOMB_COUNT; i++) {
          const dir  = Math.random() < 0.5 ? 1 : -1;       // 1 = left->right, -1 = right->left
          const x    = (dir === 1) ? -1.10 : 1.10;         // spawn off-screen at side
          const y    = (Math.random()*1.8) - 0.9;
          bombs.push({
            x,
            y,
            size: 0.26 + Math.random()*0.14,
            speed: 0.010 + Math.random()*0.006,
            phase: Math.random()*100.0,
            dir
          });
        }
      }

      // --- geometry ---
      function createFish(offset, color, scale=1, direction=1) {
        var vertices = new Float32Array([
          0.5,  0.0,  0.0,
          0.2,  0.25, 0.0,
         -0.2,  0.15, 0.0,
         -0.4,  0.3,  0.0,
         -0.4, -0.3,  0.0,
         -0.2, -0.15, 0.0,
          0.2, -0.25, 0.0
        ]);
        var indices = new Uint8Array([ 0,1,6,  1,2,6,  2,5,6,  2,3,5,  3,4,5 ]);

        var v_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, v_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        var i_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i_buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        var eye_v_buffer = gl.createBuffer();
        setEyeForDirection(eye_v_buffer, direction);

        return [v_buffer, i_buffer, eye_v_buffer, color, offset, scale, direction];
      }

      function setEyeForDirection(eyeBuffer, direction) {
        var eye_vertex = (direction == -1)
          ? new Float32Array([0.2, -0.2, 0.0])
          : new Float32Array([0.2,  0.2, 0.0]);
        gl.bindBuffer(gl.ARRAY_BUFFER, eyeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      function respawnFish(index, side) {
        var fish  = all_fish[index];
        var isBig = (index === 0);

        var edgeX  = (side === 'left') ? -1.05 :  1.05;
        var jitter = (Math.random() * 0.08) - 0.04;
        var newX   = edgeX + jitter;
        var newY   = (Math.random() * 1.8) - 0.9;
        var newDir = (side === 'left') ? 1 : -1;

        fish[4] = new Float32Array([newX, newY, 0]);
        fish[6] = newDir;
        setEyeForDirection(fish[2], newDir);

        if (isBig) {
          fish[3] = new Float32Array([1.0, 0.0, 0.0, 0.7]);
          fish[5] = 1.0;
        } else {
          fish[3] = new Float32Array([Math.random(), Math.random(), Math.random(), 0.9]);
          fish[5] = 0.08 + Math.random() * 0.10;
        }
      }

      function translationMatrix(tx, ty, tz) {
        return new Float32Array([
          1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          tx,ty,tz,1
        ]);
      }

      function timeLeftSec() {
        if (gameState === 'title') return TIME_TOTAL;
        if (gameState === 'ended' && frozenTimeLeft !== null) return frozenTimeLeft;
        return Math.max(0, TIME_TOTAL - (performance.now() - startTimeMs) / 1000.0);
      }
      function addTime(sec) {
        if (gameState !== 'playing') return;
        startTimeMs -= sec * 1000.0;
      }
      function endGame(text){
        if (gameState !== 'playing') return;
        frozenTimeLeft = timeLeftSec();
        document.getElementById('banner-text').textContent = text;
        bannerEl.style.display = 'flex';
        gameState = 'ended';
      }

      // --- main loop ---
      function animate() {
        requestAnimationFrame(animate);

        gl.clearColor(0., 0., 0., 0.);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.DEPTH_TEST);

        var a_position  = gl.getAttribLocation(shaderprogram, 'a_position');
        var u_color     = gl.getUniformLocation(shaderprogram, 'u_color');
        var u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');
        var u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
        var u_mode      = gl.getUniformLocation(shaderprogram, 'u_mode');
        var u_time      = gl.getUniformLocation(shaderprogram, 'u_time');

        var tleft = timeLeftSec();
        timeEl.textContent = tleft.toFixed(1);

        var vx = 0.008;

        var player = all_fish[0];
        var player_offset = player[4];
        var player_dir = player[6];

        if (gameState === 'playing') {
          var dx = 0, dy = 0;
          if (keysDown['arrowleft'] || keysDown['a'])  dx -= 1;
          if (keysDown['arrowright']|| keysDown['d'])  dx += 1;
          if (keysDown['arrowup']   || keysDown['w'])  dy += 1;
          if (keysDown['arrowdown'] || keysDown['s'])  dy -= 1;

          if (dx !== 0 || dy !== 0) {
            var speed = baseSpeed * (keysDown['shift'] ? boostMult : 1.0);
            var len = Math.sqrt(dx*dx + dy*dy); dx/=len; dy/=len;
            player_offset[0] += dx * speed;
            player_offset[1] += dy * speed;
            var newDir = (dx >= 0) ? 1 : -1;
            if (newDir !== player_dir) {
              player[6] = newDir;
              setEyeForDirection(player[2], newDir);
              player_dir = newDir;
            }
          }
        }

        if (player_offset[0] < clampMinX) player_offset[0] = clampMinX;
        if (player_offset[0] > clampMaxX) player_offset[0] = clampMaxX;
        if (player_offset[1] < clampMinY) player_offset[1] = clampMinY;
        if (player_offset[1] > clampMaxY) player_offset[1] = clampMaxY;

        if (gameState === 'playing' && tleft <= 0) endGame('Time Up!');
        if (gameState === 'playing' && score >= TARGET_SCORE) endGame('You Win!');

        var t = performance.now() * 0.001;

        // Draw fish
        for (var r = 0; r < all_fish.length; r++) {
          var current            = all_fish[r];
          var current_v_buffer   = current[0];
          var current_i_buffer   = current[1];
          var current_eye_buffer = current[2];
          var current_color      = current[3];
          var current_offset     = current[4];
          var current_scale      = current[5];
          var current_direction  = current[6];

          if (gameState === 'playing' && r !== 0) {
            current_offset[0] += vx * current_direction;
            current_offset[1] += 0.06 * (Math.random() - 0.5);

            var margin = 0.06;
            if (current_direction === 1 && current_offset[0] > 1 + margin) {
              respawnFish(r, 'left');
            } else if (current_direction === -1 && current_offset[0] < -1 - margin) {
              respawnFish(r, 'right');
            }

            // eat collision
            const dxp = player_offset[0] - current_offset[0];
            const dyp = player_offset[1] - current_offset[1];
            const playerR = 0.12;
            const fishR = 0.09 * current_scale;
            if ((dxp*dxp + dyp*dyp) <= (playerR + fishR)*(playerR + fishR)) {
              score++;
              scoreEl.textContent = score;
              addTime(TIME_BONUS);
              eatSound();
              respawnFish(r, (player_dir === 1) ? 'left' : 'right');
              if (score >= TARGET_SCORE) endGame('You Win!');
            }
          }

          var theta = Math.random() * 10 * Math.PI / 180.0;
          var transform = new Float32Array([
            current_direction * current_scale * Math.cos(theta),  Math.sin(theta),  0, 0,
           -Math.sin(theta),  current_direction * current_scale * Math.cos(theta),  0, 0,
            0,                 0,                                  current_direction * current_scale * 1, 0,
            current_offset[0], current_offset[1],                  current_offset[2],                       1
          ]);
          gl.uniformMatrix4fv(u_transform, false, transform);
          gl.uniform1f(u_mode, 0.0);
          gl.uniform4fv(u_color, (r===0)? new Float32Array([1,0,0,0.7]) : current_color);

          gl.bindBuffer(gl.ARRAY_BUFFER, current_v_buffer);
          gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(a_position);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, current_i_buffer);
          gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

          gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.5]));
          gl.uniform1f(u_pointsize, Math.max(1.0, 20.0 * current_scale));
          gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_buffer);
          gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
          gl.enableVertexAttribArray(a_position);
          gl.drawArrays(gl.POINTS, 0, 1);
        }

        // Bombs update/draw
        const timeSec = performance.now()*0.001;
        gl.uniform1f(u_time, timeSec);

        if (gameState === 'playing') {
          for (let i = 0; i < bombs.length; i++) {
            let b = bombs[i];
            b.x += b.dir * b.speed;
            b.y += 0.018 * Math.sin((timeSec + b.phase) * 3.0);

            if (b.dir === 1 && b.x > 1.12) {
              b.x = -1.12 + ((Math.random()*0.06) - 0.03);
              b.y = (Math.random()*1.8) - 0.9;
            } else if (b.dir === -1 && b.x < -1.12) {
              b.x =  1.12 + ((Math.random()*0.06) - 0.03);
              b.y = (Math.random()*1.8) - 0.9;
            }
          }

          // player vs bombs
          const px = player_offset[0], py = player_offset[1];
          for (let i = 0; i < bombs.length; i++) {
            const b = bombs[i];
            const dxb = px - b.x, dyb = py - b.y;
            const playerR = 0.12;
            const bombR = 0.14 * b.size;
            if (dxb*dxb + dyb*dyb <= (playerR + bombR)*(playerR + bombR)) {
              bombSound();
              endGame('Game Over');
              break;
            }
          }
        }

        var a_position_attr = a_position;
        gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
        gl.vertexAttribPointer(a_position_attr, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_position_attr);

        for (let i = 0; i < bombs.length; i++) {
          const b = bombs[i];
          gl.uniform1f(u_mode, 1.0);
          gl.uniform1f(u_pointsize, Math.max(28.0, 140.0 * b.size));
          gl.uniformMatrix4fv(u_transform, false, translationMatrix(b.x, b.y, 0));
          gl.uniform4fv(u_color, new Float32Array([0,0,0,1]));
          gl.drawArrays(gl.POINTS, 0, 1);
        }
      }
    </script>
  </body>
</html>